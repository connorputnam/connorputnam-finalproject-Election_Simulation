---
title: "Lets simulate an election!"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(scales)
library(formattable)
library(SuppDists)
library(reshape2)
```

Start by reading in the senate polling data. I have this as a .cvs so it will need to manually updated from time to time. 

```{r}
polls <- read.csv("senate_polls.csv")
```

```{r}
polls <- polls %>%
  filter(state == "Georgia") %>%
  filter(race_id == "7780" | race_id == "6271") %>%
  group_by(candidate_name)
polls
```

# EDA

```{r}
EDA_polls <- polls %>% 
  group_by(candidate_name, candidate_party) %>%
  summarise(average_polling = mean(pct)) %>%
  filter(candidate_name == "Raphael Warnock" | candidate_name == "Kelly Loeffler" | candidate_name == "Doug Collins" |
         candidate_name == "Matthew Lieberman" | candidate_name == "Ed Tarver" | candidate_name == "Brian Richard Slowinski")

ggplot(EDA_polls, aes(reorder(candidate_name, average_polling), average_polling, fill = candidate_party, label = round(average_polling, 2))) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values=c("#26b3f2", "#fcd407", "#ec1e26")) +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  ylab("Polling Average(percent)") +
  xlab("Candidate") +
  geom_text(position = position_dodge(width = .9),    # move to center of bars
              vjust = -.5,    # nudge above top of bar
              size = 3) +
  ylim(0, 25)
```


```{r}
EDA_polls_rating <- polls %>% 
  group_by(fte_grade) %>%
  count(fte_grade) %>%
  mutate(fte_grade = fct_recode(fte_grade, "No Rating" = ""))

#fct_recode 

ggplot(EDA_polls_rating, aes(fte_grade, n, fill = fte_grade)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  ylab("Number of Polls Conducted") +
  xlab("Rating") +
  ggtitle("Counts per Pollster Rating") +
  labs(fill = "Ratings")
```
 
Now that the off happened...going to build the model based off of Perdue vs Ossoff and then make a function that can sub out either race

```{r}
Perdue_vs_Ossoff <- polls %>% 
  group_by(candidate_name, candidate_party, cycle) %>%
  mutate(standard_deviation = sd(pct)) %>%
  summarise(average_polling = mean(pct), standard_deviation = mean(standard_deviation)) %>%
  filter(candidate_name == "David A. Perdue" | candidate_name == "Jon Ossoff")
Perdue_vs_Ossoff


ggplot(Perdue_vs_Ossoff, aes(reorder(candidate_name, average_polling), average_polling, fill = candidate_party, label = round(average_polling, 2))) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values=c("#26b3f2", "#ec1e26")) +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  ylab("Polling Average(percent)") +
  xlab("Candidate") +
  geom_text(position = position_dodge(width = .9),    # move to center of bars
              vjust = -.5,    # nudge above top of bar
             size = 3) 
  ylim(0, 60)
```

This is where some of my priors/judgement calls come into play. I am going to use data on previous elections, as well as the over partisan lean of Geogria, and some other factor.

```{r}
#bringing in old data

historical <- read.csv("us_senate_elections.csv")
historical <- historical %>%
  filter(state == "GA" |state == "Georgia") # just geogria

average_historical <- function(select_year){
  historical %>% 
  filter(year == select_year) %>%
  filter(office == "Senate") %>%
  group_by(candidate, year, party) %>%
  summarise(average_polling = mean(projected_voteshare), actutal_voteshare = mean(actual_voteshare),
            standard_deviation = mean(sd(projected_voteshare))) 
            #standard_deviation_actual = mean(sd(actual_voteshare)))
}

#Isakson vs Barksdale and Perdue vs Nunn
summary_table <- bind_rows(average_historical("2016"), average_historical("2014"))

#formattable(summary_table,
        #    align = c("l", rep("r", rep(NCOL(summary_table)))),
        #    list(`"Summary Statistics"` = formatter("span",
            #                  style = ~style(color = "gray"))))
```

# Historical Data
```{r}
Perdue_vs_Ossoff
summary_table <- summary_table %>%
  rename("candidate_party" = party) %>%
  rename("cycle" = year) %>%
  rename("candidate_name" = candidate)
```

```{r}
total_data <- bind_rows(Perdue_vs_Ossoff, summary_table) %>%
  mutate(candidate_party = recode(candidate_party, 
                                  `REP` = "R", 
                                  `DEM` = "D")) %>%
  filter(candidate_party == "R" | candidate_party == "D") %>% #2020 election will not have independents, only top two advance
  group_by(cycle) %>%
  arrange(cycle, candidate_party) %>%
  mutate(spread = average_polling - lag(average_polling)) %>%
  fill(spread, .direction = "up") %>%
  mutate(spread = case_when(candidate_party == "R" ~ spread,
                            candidate_party == "D" ~ (-1 * spread))) #creating the spread for both candidates based on party. THis took be a longggg time to figure out
  #pivot_longer(cols = c(candidate_name, average_polling, standard_deviation), names_to = "variables", values_to = "times")
total_data
```

# Johnson vs Normal

```{r}
n <- 100000
parmamter_data <- polls %>% 
  group_by(candidate_name) %>%
  select(candidate_name, pct) %>%
  filter(candidate_name == "David A. Perdue" | candidate_name == "Jon Ossoff")
paramters <- JohnsonFit(parmamter_data$pct)

johnson_dist <- rJohnson(n = n, 
                         parms = list(gamma = 0, 
                                      delta = .5, 
                                      xi = 0, #no really sure what this parameter is doing...
                                      lambda = 2, 
                                      type = "SN"))

normal_dist <- rnorm(n = n, mean = 0, sd = 1)

overlay <- melt(as.data.frame(cbind(johnson_dist, normal_dist)))

ggplot(overlay, aes(value, fill = variable)) +
  geom_density(alpha = 0.5)
#fat tails!
```

## Set up for computing the distributions of spreads in regards to jon ossoff

empty_vec <- rep((total_data %>% filter(cycle == "2020") %>% filter(candidate_name == "David A. Perdue"))$spread , 100)
#perdue is in two races....casuing headaches here
Ossof <- (sd(johnson_dist) * johnson_dist) + empty_vec

ggplot(data.frame(Ossof), aes(x = Ossof)) +
  geom_density() +
  geom_vline(xintercept = mean(Ossof))

win <- length(which(Ossof > 0)) / n #prob  winning
lose <- length(which(Ossof < 0)) / n #prob  losing

cbind(win, lose)

- meaning democrate closes by that much, and positive means wins by that much




# Bootstrapping

```{r}
boot_data <- polls %>% 
  group_by(candidate_name, candidate_party, cycle) %>%
  filter(candidate_name == "David A. Perdue" | candidate_name == "Jon Ossoff")

boot_data <- boot_data %>%
  mutate(candidate_party = recode(candidate_party, 
                                  `REP` = "R", 
                                  `DEM` = "D")) %>%
  filter(candidate_party == "R" | candidate_party == "D") %>% #2020 election will not have independents, only top two advance
  group_by(question_id) %>%
  #arrange(question_id, candidate_party) %>%
  select(question_id, poll_id, fte_grade, sample_size, candidate_name, candidate_party, pct) %>%
  filter(question_id != 123442 & question_id != 123443) %>%
  mutate(spread = pct - pct[candidate_party == "D"]) %>%
  mutate(spread2 = pct - pct[candidate_party == "R"]) %>%
  mutate(actual_spread = spread + spread2) %>%
  select(-spread, -spread2)
boot_data
```

```{r}
fake_polls <- as.data.frame(round(runif(10000, min = 0, max = 8), 1))
colnames(fake_polls) <- "fake_spread"
fake_polls <- fake_polls %>%
  #rename(fake_spread = "round(runif(10000, min = 0, max = 8), 1)") %>%
  slice(rep(1:n(), each = 2)) %>%
  mutate(ID = row_number()) %>%
  mutate(candidate_name = case_when((ID %% 2 == 0) ~ "David A. Perdue",
                                    (ID %% 2 != 0) ~ "Jon Ossoff")) %>%
  mutate(fake_spread = case_when((ID %% 2 == 0) ~ fake_spread,
                                 (ID %% 2 != 0) ~ fake_spread * -1))
fake_polls
  
```

```{r}
ggplot(fake_polls, aes(fake_spread)) +
  geom_histogram()
```


```{r}
ggplot(boot_data, aes(actual_spread)) +
  geom_histogram(bins = 15)
```

```{r}
boot_spread <- map(1:10000, ~sample(boot_data$actual_spread, size = length(boot_data), replace = TRUE)) %>%
  map_dbl(mean)

boot_spread <- melt(boot_spread)
ggplot(boot_spread, aes(value)) +
  geom_histogram(aes(y=..density..)) +
  stat_function(fun = dnorm, args = c(mean = mean(boot_spread$value), sd = sd(boot_spread$value))) +
  geom_vline(xintercept = mean(boot_spread$value)) +
  labs(title = "Bootstrapped Spreads")
```

```{r}
fit <- MASS:: fitdistr(boot_spread$value, "normal")
#fit <- fitdistrplus::fitdist(boot_spread$value, "unif")
fit

mean(boot_spread$value)
```


```{r}
## Set up for computing the distributions of spreads in regards to jon ossoff

reps <- 10000

empty_vec <- rep((boot_data %>%
                    group_by(candidate_name) %>%
                    summarise(average_spread = mean(actual_spread)) %>%
                    filter(candidate_name == "David A. Perdue") %>%
                    select(average_spread)), reps) %>%
                    flatten_dbl()

#This is where the actual predictions are now taking place

Perdue <- (as.numeric(fit$estimate[2]) * rnorm(n, as.numeric(fit$estimate[1]), 
                                                     as.numeric(fit$estimate[2]))) + empty_vec 

#Ossof <- (sd(johnson_dist) * johnson_dist) + empty_vec

ggplot(data.frame(Perdue), aes(x = Perdue)) +
  geom_density() +
  geom_vline(xintercept = mean(Perdue))

win <- length(which(Perdue > 0)) / n #prob  winning
lose <- length(which(Perdue < 0)) / n #prob  losing

cbind(win, lose)
```

```{r}

```

```{r}
# in terms of ossof
empty_vec_ossof <- rep((boot_data %>%
                    group_by(candidate_name) %>%
                    summarise(average_spread = mean(actual_spread)) %>%
                    filter(candidate_name == "Jon Ossoff") %>%
                    select(average_spread)), reps) %>%
                    flatten_dbl()

#This is where the actual predictions are now taking place

Ossof <- (as.numeric(fit$estimate[2]) * rnorm(n, as.numeric(fit$estimate[1]), 
                                                     as.numeric(fit$estimate[2]))) + empty_vec_ossof 

#Ossof <- (sd(johnson_dist) * johnson_dist) + empty_vec

ggplot(data.frame(Ossof), aes(x = Ossof)) +
  geom_density() +
  geom_vline(xintercept = mean(Ossof))

win_ossof <- length(which(Ossof > 0)) / n #prob  winning
lose_ossof <- length(which(Ossof < 0)) / n #prob  losing

cbind(win_ossof, lose_ossof)
```


```{r}
combined_probs <- melt(as.data.frame(cbind(Perdue, Ossof)))
combined_probs <- combined_probs %>% 
  group_by(variable) %>%
  mutate_at(vars(variable), as.character) %>%
  mutate(wining_color = case_when((variable == "Perdue" & value > 0) ~ "win",
                                   (variable == "Perdue" & value < 0) ~ "lose",
                                   (variable == "Ossof" & value > 0) ~ "win",
                                   (variable == "Ossof" & value < 0) ~ "lose"))
  #mutate(color_perdue = ifelse(value > 0, "red", "blue")) %>%
  #mutate(color_ossof = ifelse(variable 0 & value > 0, "blue", "red"))
combined_probs <- combined_probs %>%
  mutate(prob_winning = case_when((variable == "Perdue" & 
                                    wining_color == "win" ~ 
                                    length(which(Perdue > 0)) / n),
                                  (variable == "Perdue" & 
                                    wining_color == "lose" ~ 
                                    length(which(Perdue < 0)) / n),
                                  (variable == "Ossof" & 
                                    wining_color == "win" ~ 
                                    length(which(Ossof > 0)) / n),
                                  (variable == "Ossof" & 
                                    wining_color == "lose" ~ 
                                    length(which(Ossof < 0)) / n)))

ggplot(combined_probs, aes(value, fill = variable)) +
  geom_histogram(aes(fill = wining_color)) +
  scale_x_continuous(breaks = 0) +
  #geom_vline(xintercept = 0) +
  facet_wrap(~ variable, ncol = 1)
```

```{r}
probability_winning_plot <- function(candidate){
ggplot((combined_probs %>% filter(variable == sprintf(candidate))), aes(value)) +
  geom_histogram(aes(fill = wining_color), color = "black", bins = 30) +
  ggthemes::theme_fivethirtyeight() +
  theme(axis.title = element_text()) + xlab("Spread") + ylab("Number of Observations") +
  theme(legend.title = element_blank()) +
  scale_x_continuous(breaks = c(-5:5)) +
  labs(title = sprintf("Probability of Winning vs Losing for %s", candidate)) +
  annotate(geom = "text", x = 5, y = 8000, 
           label = sprintf("Winning : %s", 
                           combined_probs %>% 
                             filter(wining_color == "win" & variable == candidate) %>% 
                             summarise(label_percent(accuracy = 0.01)(mean(prob_winning))) %>% 
                             select(-variable) %>% flatten_chr()),
           color = "#00BFC4") +
  annotate(geom = "text", x = -5, y = 8000, label = sprintf("Losing : %s", 
                           combined_probs %>% 
                             filter(wining_color == "lose" & variable == candidate) %>% 
                             summarise(label_percent(accuracy = 0.01)(mean(prob_winning))) %>% 
                             select(-variable) %>% flatten_chr()), 
           color = "#F8766D")
}
probability_winning_plot("Perdue")
```

```{r}
probability_winning_plot("Ossof")
```


## Fake Data for Testing

```{r}
fake_polls
```



